<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>NYC Flood Final Model</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050510; font-family: 'Helvetica Neue', Arial, sans-serif; }
        
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }
        h1 { color: #fff; margin: 0 0 5px 0; font-size: 24px; text-shadow: 0 0 10px rgba(0,180,255,0.6); }
        .subtitle { color: #8899aa; font-size: 14px; margin-bottom: 20px; }
        
        #status-panel {
            background: rgba(15, 20, 25, 0.95);
            border-left: 5px solid #666;
            padding: 15px;
            width: 320px;
            border-radius: 0 8px 8px 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6);
            transition: all 0.3s;
        }
        .status-title { font-size: 18px; font-weight: bold; color: #fff; display: block; margin-bottom: 5px; }
        .status-desc { font-size: 13px; color: #ccc; line-height: 1.5; }

        .mode-idle { border-color: #666; }
        .mode-safe { border-color: #28a745; }
        .mode-danger { border-color: #dc3545; }

        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 20;
            background: rgba(255,255,255,0.08);
            padding: 12px 20px;
            border-radius: 16px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        button {
            border: none;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            color: white;
            transition: all 0.2s;
            min-width: 110px;
            text-transform: uppercase;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        button:hover { transform: translateY(-2px); filter: brightness(1.1); }
        
        .btn-light { background: #17a2b8; opacity: 0.7; }
        .btn-heavy { background: #dc3545; opacity: 0.7; }
        .btn-auto { background: #007bff; opacity: 0.7; }
        .btn-reset { background: #555; opacity: 0.7; }
        .active { opacity: 1.0 !important; box-shadow: 0 0 15px inset rgba(0,0,0,0.3); border: 2px solid white; }

        .label {
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.3);
            white-space: nowrap;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>

<div id="ui-layer">
    <h1>NYC Urban Flood Model</h1>
    <div class="subtitle">Realistic Flood Levels • Sponge Effect</div>
    
    <div id="status-panel" class="mode-idle">
        <span class="status-title">IDLE (DRY)</span>
        <span class="status-desc">No rain. Ground is dry.<br>Click a button to start.</span>
    </div>
</div>

<div id="controls">
    <button id="btn-light" class="btn-light" onclick="window.toggleMode('light')">Light Rain</button>
    <button id="btn-heavy" class="btn-heavy" onclick="window.toggleMode('heavy')">Heavy Rain</button>
    <button id="btn-auto" class="btn-auto" onclick="window.toggleMode('auto')">Auto Demo</button>
    <button id="btn-reset" class="btn-reset" onclick="window.resetSystem()">Reset</button>
</div>

<div id="lbl-cp" class="label">Central Park</div>
<div id="lbl-esb" class="label">Empire State</div>
<div id="lbl-wtc" class="label">One WTC</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // === 1. 场景 ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510);
    scene.fog = new THREE.Fog(0x050510, 15, 60);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 5, 12); // 稍微降低视角，更适合看街道积水

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 2 - 0.1;

    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(5, 10, 8);
    sun.castShadow = true;
    scene.add(sun);

    // === 2. 模型 (NYC) ===
    const cityGroup = new THREE.Group();

    // 地面
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 1.0 });
    const ground = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 7), groundMat);
    ground.position.y = -0.25;
    ground.receiveShadow = true;
    cityGroup.add(ground);

    // 中央公园
    const park = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.52, 2.8), new THREE.MeshStandardMaterial({ color: 0x2d5a27 }));
    park.position.set(0, -0.25, -0.5);
    park.receiveShadow = true;
    cityGroup.add(park);

    // 建筑
    const buildMat = new THREE.MeshStandardMaterial({ color: 0x888899 });
    const glassMat = new THREE.MeshPhysicalMaterial({ color: 0xaaccff, metalness: 0.1, roughness: 0.1, transmission: 0.2 });

    function createBuilding(x, z, w, d, h, isGlass = false) {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), isGlass ? glassMat : buildMat);
        mesh.position.set(x, h/2 - 0.5, z); // 底部对齐
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        cityGroup.add(mesh);
    }

    for(let i=0; i<70; i++) {
        const x = (Math.random()-0.5) * 3.6;
        const z = (Math.random()-0.5) * 6.6;
        if (Math.abs(x) < 0.7 && z > -2.0 && z < 1.0) continue;
        const h = 0.4 + Math.random() * 1.5;
        createBuilding(x, z, 0.25, 0.25, h);
    }
    // Landmarks (高楼)
    createBuilding(0.2, 1.5, 0.4, 0.3, 3.2, true); // ESB
    createBuilding(-0.3, 2.8, 0.4, 0.4, 3.5, true); // WTC

    scene.add(cityGroup);

    // === 3. 水系统 ===
    // 玻璃盒 (降低高度，匹配新的水位上限)
    const tray = new THREE.Mesh(
        new THREE.BoxGeometry(4.2, 1.5, 7.2),
        new THREE.MeshPhysicalMaterial({ color: 0x88ccff, transmission: 0.95, opacity: 0.1, transparent: true, side: THREE.DoubleSide, depthWrite: false })
    );
    tray.position.y = 0.5; // 刚好包住可能的最高水位
    scene.add(tray);

    const floodWater = new THREE.Mesh(
        new THREE.BoxGeometry(4.1, 1, 7.1),
        new THREE.MeshPhysicalMaterial({ color: 0x0066ff, transmission: 0.8, opacity: 0.9, transparent: true })
    );
    floodWater.position.y = 0;
    floodWater.scale.y = 0.0001;
    scene.add(floodWater);

    const funnel = new THREE.Mesh(new THREE.ConeGeometry(1.0, 1.5, 32, 1, true), new THREE.MeshStandardMaterial({ color: 0xffaa00, side: THREE.DoubleSide }));
    funnel.rotation.x = Math.PI;
    funnel.position.y = -1.0;
    scene.add(funnel);

    const stream = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2, 0.2, 3),
        new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 })
    );
    stream.position.y = -3.2;
    stream.visible = false;
    scene.add(stream);

    // === 4. 雨 ===
    const rainCount = 5000;
    const rainGeo = new THREE.BufferGeometry();
    const rainPos = new Float32Array(rainCount * 6);
    rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
    const rainMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0 });
    const rainSystem = new THREE.LineSegments(rainGeo, rainMat);
    scene.add(rainSystem);

    for(let i=0; i<rainCount*6; i+=6) {
        const x = (Math.random()-0.5)*4.2;
        const z = (Math.random()-0.5)*7.2;
        const y = Math.random()*15 + 5;
        rainPos[i]=x; rainPos[i+1]=y; rainPos[i+2]=z;
        rainPos[i+3]=x; rainPos[i+4]=y-0.6; rainPos[i+5]=z;
    }

    // === 5. 逻辑 ===
    let state = {
        activeMode: null,
        isRaining: false,
        waterLevel: 0,
        groundWetness: 0,
        rainOpacity: 0,
        rainSpeed: 0,
        autoTimer: 0
    };

    const uiTitle = document.querySelector('.status-title');
    const uiDesc = document.querySelector('.status-desc');
    const uiPanel = document.getElementById('status-panel');
    const btnLight = document.getElementById('btn-light');
    const btnHeavy = document.getElementById('btn-heavy');
    const btnAuto = document.getElementById('btn-auto');

    function updateUI() {
        [btnLight, btnHeavy, btnAuto].forEach(b => b.classList.remove('active'));
        if (state.activeMode === 'light') btnLight.classList.add('active');
        if (state.activeMode === 'heavy') btnHeavy.classList.add('active');
        if (state.activeMode === 'auto') btnAuto.classList.add('active');

        if (state.activeMode === 'auto') {
            uiTitle.innerText = "AUTO DEMO RUNNING";
            uiDesc.innerText = "Sequence: Light -> Heavy -> Drain";
            uiPanel.className = "mode-safe";
        }
        else if (state.isRaining) {
            if (state.activeMode === 'light') {
                uiTitle.innerText = "LIGHT RAIN";
                uiDesc.innerText = "Drainage Handling OK.\nNo Flooding.";
                uiPanel.className = "mode-safe";
            } else {
                uiTitle.innerText = "HEAVY RAIN (FLOODING)";
                uiDesc.innerText = "System Overwhelmed.\nStreet Level Flooding!";
                uiPanel.className = "mode-danger";
            }
        } 
        else {
            if (state.waterLevel > 0.01) {
                uiTitle.innerText = "DRAINING...";
                uiDesc.innerText = "Rain stopped. Water level dropping.";
                uiPanel.className = "mode-safe";
            } else {
                uiTitle.innerText = "IDLE (DRY)";
                uiDesc.innerText = "System ready.";
                uiPanel.className = "mode-idle";
            }
        }
    }

    window.toggleMode = (mode) => {
        if (mode === 'auto') {
            window.resetSystem();
            state.activeMode = 'auto';
            state.autoTimer = 0;
            updateUI();
            return;
        }
        if (state.activeMode === mode) {
            state.activeMode = null;
            state.isRaining = false;
        } else {
            state.activeMode = mode;
            state.isRaining = true;
        }
        updateUI();
    };

    window.resetSystem = () => {
        state.activeMode = null;
        state.isRaining = false;
        state.waterLevel = 0;
        state.groundWetness = 0;
        state.rainOpacity = 0;
        state.rainSpeed = 0;
        updateUI();
    };

    function updatePhysics(dt) {
        // 自动演示逻辑
        if (state.activeMode === 'auto') {
            state.autoTimer += dt;
            if (state.autoTimer < 1) {}
            else if (state.autoTimer < 6) { 
                if(!state.isRaining || state.rainSpeed > 1) { state.isRaining=true; state.rainSpeed=0.5; } 
            }
            else if (state.autoTimer < 16) {
                if(state.rainSpeed < 1) { state.rainSpeed=2.5; }
            }
            else if (state.autoTimer < 25) {
                state.isRaining = false; 
            } else {
                state.activeMode = null;
                updateUI();
            }
        } else {
            if (state.activeMode === 'light') state.rainSpeed = 0.5;
            else if (state.activeMode === 'heavy') state.rainSpeed = 2.5;
            else state.rainSpeed = 0;
        }

        // 物理
        let inflow = 0;
        const drainageCapacity = 0.05;

        if (state.isRaining) {
            if (state.rainSpeed > 1) inflow = 0.35;
            else inflow = 0.04;
        }

        // 吸水
        if (inflow > 0) {
            if (state.groundWetness < 1) {
                state.groundWetness += dt * 0.5;
                inflow *= 0.2;
            }
        } else {
            state.groundWetness -= dt * 0.05;
        }
        state.groundWetness = Math.max(0, Math.min(1, state.groundWetness));
        groundMat.color.setScalar(0.33 - state.groundWetness * 0.2);

        // 水位计算
        let actualOutflow = 0;
        if (state.waterLevel > 0 || inflow > 0) {
            actualOutflow = drainageCapacity;
            if (state.waterLevel <= 0 && inflow < actualOutflow) actualOutflow = inflow;
        }

        let netFlow = inflow - actualOutflow;
        
        if (state.waterLevel > 0 || netFlow > 0) {
            state.waterLevel += netFlow * dt * 0.8;
        }

        // 【关键修复】限制最高水位为 0.85
        // 0.85 大约淹没到低矮建筑的顶部，但远低于摩天大楼
        if (state.waterLevel < 0) state.waterLevel = 0;
        if (state.waterLevel > 0.85) state.waterLevel = 0.85;

        // 视觉更新
        floodWater.scale.y = Math.max(0.0001, state.waterLevel);
        floodWater.visible = state.waterLevel > 0.001;
        // 让水面从地面(-0.5相对坐标)升起
        floodWater.position.y = -0.5 + (state.waterLevel / 2); 

        stream.visible = (actualOutflow > 0.01 && state.waterLevel > 0);
        if (stream.visible) stream.scale.setScalar(1 + Math.sin(Date.now()*0.02)*0.1);

        const targetOp = state.isRaining ? (state.rainSpeed > 1 ? 0.8 : 0.15) : 0;
        state.rainOpacity += (targetOp - state.rainOpacity) * 0.1;
        rainMat.opacity = state.rainOpacity;

        if (state.rainOpacity > 0.01) {
            const pos = rainSystem.geometry.attributes.position.array;
            const spd = state.rainSpeed * 0.4 + 0.2;
            for(let i=0; i<rainCount*6; i+=6) {
                pos[i+1] -= spd; pos[i+4] -= spd;
                if(pos[i+1] < 0) {
                    const ny = Math.random()*15 + 5;
                    pos[i+1] = ny; pos[i+4] = ny-0.6;
                }
            }
            rainSystem.geometry.attributes.position.needsUpdate = true;
        }
    }

    function updateLabels() {
        const labels = [
            { id: 'lbl-cp', vec: new THREE.Vector3(0, 0, -0.5) },
            { id: 'lbl-esb', vec: new THREE.Vector3(0.2, 3.2, 1.5) },
            { id: 'lbl-wtc', vec: new THREE.Vector3(-0.3, 3.5, 2.8) }
        ];
        labels.forEach(l => {
            const el = document.getElementById(l.id);
            const v = l.vec.clone().project(camera);
            if(Math.abs(v.z)<1) {
                const x = (v.x*.5+.5)*window.innerWidth;
                const y = (-(v.y*.5)+.5)*window.innerHeight;
                el.style.transform = `translate(-50%,-50%) translate(${x}px,${y}px)`;
                el.style.display = 'block';
            } else el.style.display = 'none';
        });
    }

    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        updatePhysics(clock.getDelta());
        updateLabels();
        controls.update();
        renderer.render(scene, camera);
        if (!state.activeMode && (state.waterLevel > 0 || state.waterLevel === 0)) updateUI();
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
